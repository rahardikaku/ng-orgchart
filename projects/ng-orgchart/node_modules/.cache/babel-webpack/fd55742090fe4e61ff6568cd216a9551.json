{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:/Development/COOFIS UI/dabeng-orgchart/ng-orgchart/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass JSONDigger {\n  constructor(datasource, idProp, childrenProp) {\n    this.ds = datasource;\n    this.id = idProp;\n    this.children = childrenProp;\n    this.count = 0;\n  }\n\n  countNodes(obj) {\n    var _this = this;\n\n    this.count++;\n\n    if (!obj || !Object.keys(obj).length) {\n      return false;\n    } else {\n      if (obj[this.children]) {\n        obj[this.children].forEach(child => {\n          _this.countNodes(child);\n        });\n      }\n    }\n  }\n\n  findNodeById(id) {\n    const _this = this;\n\n    this.countNodes(this.ds);\n    return new Promise((resolve, reject) => {\n      if (!id) {\n        return reject(new Error('Parameter id is invalid.'));\n      }\n\n      function findNodeById(obj, id, callback) {\n        if (!_this.count) {\n          return;\n        }\n\n        if (obj[_this.id] === id) {\n          _this.count = 0;\n          callback(null, obj);\n        } else {\n          if (_this.count === 1) {\n            _this.count = 0;\n            callback('The node doesn\\'t exist.', null);\n          }\n\n          _this.count--;\n\n          if (obj[_this.children]) {\n            obj[_this.children].forEach(node => {\n              findNodeById(node, id, callback);\n            });\n          }\n        }\n      }\n\n      findNodeById(this.ds, id, (msg, node) => {\n        if (msg) {\n          reject(new Error(msg));\n        } else {\n          resolve(node);\n        }\n      });\n    });\n  }\n\n  matchConditions(obj, conditions) {\n    var flag = true;\n    Object.keys(conditions).some(item => {\n      if (typeof conditions[item] === 'string' || typeof conditions[item] === 'number' || typeof conditions[item] === 'boolean') {\n        if (obj[item] !== conditions[item]) {\n          flag = false;\n          return true;\n        }\n      } else if (conditions[item] instanceof RegExp) {\n        if (!conditions[item].test(obj[item])) {\n          flag = false;\n          return true;\n        }\n      } else if (typeof conditions[item] === 'object') {\n        Object.keys(conditions[item]).some(subitem => {\n          switch (subitem) {\n            case '>':\n              {\n                if (!(obj[item] > conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '<':\n              {\n                if (!(obj[item] < conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '>=':\n              {\n                if (!(obj[item] >= conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '<=':\n              {\n                if (!(obj[item] <= conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '!==':\n              {\n                if (!(obj[item] !== conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n          }\n        });\n\n        if (!flag) {\n          return false;\n        }\n      }\n    });\n    return flag;\n  }\n\n  findChildren(id) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const _this = _this2;\n\n      if (!id) {\n        throw new Error('Parameter id is invalid.');\n      }\n\n      try {\n        const parent = yield _this2.findParent(id);\n        return parent[_this2.children];\n      } catch (err) {\n        throw new Error('The child nodes don\\'t exist.');\n      }\n    })();\n  }\n\n  findNodes(conditions) {\n    var _this3 = this;\n\n    const _this = this;\n\n    this.countNodes(this.ds);\n    return new Promise( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (resolve, reject) {\n        if (!conditions || !Object.keys(conditions).length) {\n          return reject(new Error('Parameter conditions are invalid.'));\n        }\n\n        let nodes = [];\n\n        function findNodes(obj, conditions, callback) {\n          if (!_this.count) {\n            return;\n          }\n\n          if (_this.matchConditions(obj, conditions)) {\n            nodes.push(obj);\n\n            if (_this.count === 1) {\n              _this.count = 0;\n              callback(!nodes.length ? 'The nodes don\\'t exist.' : null, nodes.slice(0));\n            }\n          } else {\n            if (_this.count === 1) {\n              _this.count = 0;\n              callback(!nodes.length ? 'The nodes don\\'t exist.' : null, nodes.slice(0));\n            }\n          }\n\n          _this.count--;\n\n          if (obj[_this.children]) {\n            obj[_this.children].forEach(child => {\n              findNodes(child, conditions, callback);\n            });\n          }\n        }\n\n        findNodes(_this3.ds, conditions, (msg, nodes) => {\n          if (msg) {\n            reject(new Error(msg));\n          } else {\n            resolve(nodes);\n          }\n        });\n      });\n\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n\n  findParent(id) {\n    const _this = this;\n\n    this.countNodes(this.ds);\n    return new Promise((resolve, reject) => {\n      if (!id) {\n        return reject(new Error('Parameter id is invalid.'));\n      }\n\n      function findParent(obj, id, callback) {\n        if (_this.count === 1) {\n          _this.count = 0;\n          callback('The parent node doesn\\'t exist.', null);\n        } else {\n          _this.count--;\n\n          if (typeof obj[_this.children] !== 'undefined') {\n            obj[_this.children].forEach(function (child) {\n              if (child[_this.id] === id) {\n                _this.count = 0;\n                callback(null, obj);\n              }\n            });\n\n            obj[_this.children].forEach(function (child) {\n              findParent(child, id, callback);\n            });\n          }\n        }\n      }\n\n      findParent(this.ds, id, (msg, parent) => {\n        if (msg) {\n          reject(new Error(msg));\n        } else {\n          resolve(parent);\n        }\n      });\n    });\n  }\n\n  findSiblings(id) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const _this = _this4;\n\n      if (!id) {\n        throw new Error('Parameter id is invalid.');\n      }\n\n      try {\n        const parent = yield _this4.findParent(id);\n        return parent[_this4.children].filter(child => {\n          return child[_this.id] !== id;\n        });\n      } catch (err) {\n        throw new Error('The sibling nodes don\\'t exist.');\n      }\n    })();\n  }\n\n  findAncestors(id) {\n    const _this = this;\n\n    return new Promise( /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (resolve, reject) {\n        if (!id) {\n          return reject(new Error('Parameter id is invalid.'));\n        }\n\n        let nodes = [];\n\n        function findAncestors(_x5) {\n          return _findAncestors.apply(this, arguments);\n        }\n\n        function _findAncestors() {\n          _findAncestors = _asyncToGenerator(function* (id) {\n            try {\n              if (id === _this.ds[_this.id]) {\n                if (!nodes.length) {\n                  throw new Error('The ancestor nodes don\\'t exist.');\n                }\n\n                return nodes.slice(0);\n              } else {\n                const parent = yield _this.findParent(id);\n                nodes.push(parent);\n                return findAncestors(parent[_this.id]);\n              }\n            } catch (err) {\n              throw new Error('The ancestor nodes don\\'t exist.');\n            }\n          });\n          return _findAncestors.apply(this, arguments);\n        }\n\n        try {\n          const ancestors = yield findAncestors(id);\n          resolve(ancestors);\n        } catch (err) {\n          reject(err);\n        }\n      });\n\n      return function (_x3, _x4) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n  } // validate the input parameters id and data(could be oject or array)\n\n\n  validateParams(id, data) {\n    if (!id) {\n      throw new Error('Parameter id is invalid.');\n    }\n\n    if (!data || data.constructor !== Object && data.constructor !== Array || data.constructor === Object && !Object.keys(data).length || data.constructor === Array && !data.length || data.constructor === Array && data.length && !data.every(item => item && item.constructor === Object && Object.keys(item).length)) {\n      throw new Error('Parameter data is invalid.');\n    }\n  }\n\n  addChildren(id, data) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      _this5.validateParams(id, data);\n\n      try {\n        const parent = yield _this5.findNodeById(id);\n\n        if (data.constructor === Object) {\n          if (parent[_this5.children]) {\n            parent[_this5.children].push(data);\n          } else {\n            parent[_this5.children] = [data];\n          }\n        } else {\n          if (parent[_this5.children]) {\n            parent[_this5.children].push(...data);\n          } else {\n            parent[_this5.children] = data;\n          }\n        }\n      } catch (err) {\n        throw new Error('Failed to add child nodes.');\n      }\n    })();\n  }\n\n  addSiblings(id, data) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      _this6.validateParams(id, data);\n\n      try {\n        const parent = yield _this6.findParent(id);\n\n        if (data.constructor === Object) {\n          parent[_this6.children].push(data);\n        } else {\n          parent[_this6.children].push(...data);\n        }\n      } catch (err) {\n        throw new Error('Failed to add sibling nodes.');\n      }\n    })();\n  }\n\n  addRoot(data) {\n    const _this = this;\n\n    if (!data || data.constructor !== Object || data.constructor === Object && !Object.keys(data).length) {\n      throw new Error('Parameter data is invalid.');\n    }\n\n    try {\n      this.ds[this.children] = [Object.assign({}, this.ds)];\n      delete data[this.children];\n      Object.keys(this.ds).filter(prop => prop !== this.children).forEach(prop => {\n        if (!data[prop]) {\n          delete this.ds[prop];\n        }\n      });\n      Object.assign(this.ds, data);\n    } catch (err) {\n      throw new Error('Failed to add root node.');\n    }\n  }\n\n  updateNode(data) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!data || data.constructor !== Object || data.constructor === Object && !Object.keys(data).length || data.constructor === Object && Object.keys(data).length && !data[_this7.id]) {\n        throw new Error('Parameter data is invalid.');\n      }\n\n      try {\n        const node = yield _this7.findNodeById(data[_this7.id]);\n        Object.assign(node, data);\n      } catch (err) {\n        throw new Error('Failed to update node.');\n      }\n    })();\n  }\n\n  updateNodes(ids, data) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const _this = _this8;\n\n      if (!ids || ids.constructor === Array && !ids.length || !data) {\n        throw new Error('Input parameter is invalid.');\n      }\n\n      try {\n        for (const id of ids) {\n          data[_this.id] = id;\n          yield _this8.updateNode(data);\n        }\n      } catch (err) {\n        throw err;\n      }\n    })();\n  } // remove single node based on id\n\n\n  removeNode(id) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const _this = _this9;\n\n      if (id === _this9.ds[_this9.id]) {\n        throw new Error('Input parameter is invalid.');\n      }\n\n      const parent = yield _this9.findParent(id);\n\n      const index = parent[_this9.children].map(node => node[_this.id]).indexOf(id);\n\n      parent[_this9.children].splice(index, 1);\n\n      _this9.count = 0;\n    })();\n  } // param could be single id, id array or conditions object\n\n\n  removeNodes(param) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const _this = _this10;\n\n      if (!param || param.constructor === Array && !param.length || param.constructor === Object && !Object.keys(param).length) {\n        throw new Error('Input parameter is invalid.');\n      }\n\n      try {\n        // if passing in single id\n        if (param.constructor === String || param.constructor === Number) {\n          yield _this10.removeNode(param);\n        } else if (param.constructor === Array) {\n          // if passing in id array\n          for (const p of param) {\n            yield _this10.removeNode(p);\n          }\n        } else {\n          // if passing in conditions object\n          const nodes = yield _this10.findNodes(param);\n          const ids = nodes.map(node => node[_this.id]);\n\n          for (const p of ids) {\n            yield _this10.removeNode(p);\n          }\n        }\n      } catch (err) {\n        throw new Error('Failed to remove nodes.');\n      }\n    })();\n  }\n\n}\n\nexports.default = JSONDigger;\n;","map":{"version":3,"sources":["D:/Development/COOFIS UI/dabeng-orgchart/ng-orgchart/node_modules/json-digger/dist/index.js"],"names":["Object","defineProperty","exports","value","default","JSONDigger","constructor","datasource","idProp","childrenProp","ds","id","children","count","countNodes","obj","_this","keys","length","forEach","child","findNodeById","Promise","resolve","reject","Error","callback","node","msg","matchConditions","conditions","flag","some","item","RegExp","test","subitem","findChildren","parent","findParent","err","findNodes","nodes","push","slice","findSiblings","filter","findAncestors","ancestors","validateParams","data","Array","every","addChildren","addSiblings","addRoot","assign","prop","updateNode","updateNodes","ids","removeNode","index","map","indexOf","splice","removeNodes","param","String","Number","p"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass JSONDigger {\n  constructor(datasource, idProp, childrenProp) {\n    this.ds = datasource;\n    this.id = idProp;\n    this.children = childrenProp;\n    this.count = 0;\n  }\n\n  countNodes(obj) {\n    var _this = this;\n\n    this.count++;\n\n    if (!obj || !Object.keys(obj).length) {\n      return false;\n    } else {\n      if (obj[this.children]) {\n        obj[this.children].forEach(child => {\n          _this.countNodes(child);\n        });\n      }\n    }\n  }\n\n  findNodeById(id) {\n    const _this = this;\n\n    this.countNodes(this.ds);\n    return new Promise((resolve, reject) => {\n      if (!id) {\n        return reject(new Error('Parameter id is invalid.'));\n      }\n\n      function findNodeById(obj, id, callback) {\n        if (!_this.count) {\n          return;\n        }\n\n        if (obj[_this.id] === id) {\n          _this.count = 0;\n          callback(null, obj);\n        } else {\n          if (_this.count === 1) {\n            _this.count = 0;\n            callback('The node doesn\\'t exist.', null);\n          }\n\n          _this.count--;\n\n          if (obj[_this.children]) {\n            obj[_this.children].forEach(node => {\n              findNodeById(node, id, callback);\n            });\n          }\n        }\n      }\n\n      findNodeById(this.ds, id, (msg, node) => {\n        if (msg) {\n          reject(new Error(msg));\n        } else {\n          resolve(node);\n        }\n      });\n    });\n  }\n\n  matchConditions(obj, conditions) {\n    var flag = true;\n    Object.keys(conditions).some(item => {\n      if (typeof conditions[item] === 'string' || typeof conditions[item] === 'number' || typeof conditions[item] === 'boolean') {\n        if (obj[item] !== conditions[item]) {\n          flag = false;\n          return true;\n        }\n      } else if (conditions[item] instanceof RegExp) {\n        if (!conditions[item].test(obj[item])) {\n          flag = false;\n          return true;\n        }\n      } else if (typeof conditions[item] === 'object') {\n        Object.keys(conditions[item]).some(subitem => {\n          switch (subitem) {\n            case '>':\n              {\n                if (!(obj[item] > conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '<':\n              {\n                if (!(obj[item] < conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '>=':\n              {\n                if (!(obj[item] >= conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '<=':\n              {\n                if (!(obj[item] <= conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n\n            case '!==':\n              {\n                if (!(obj[item] !== conditions[item][subitem])) {\n                  flag = false;\n                  return true;\n                }\n\n                break;\n              }\n          }\n        });\n\n        if (!flag) {\n          return false;\n        }\n      }\n    });\n    return flag;\n  }\n\n  async findChildren(id) {\n    const _this = this;\n\n    if (!id) {\n      throw new Error('Parameter id is invalid.');\n    }\n\n    try {\n      const parent = await this.findParent(id);\n      return parent[this.children];\n    } catch (err) {\n      throw new Error('The child nodes don\\'t exist.');\n    }\n  }\n\n  findNodes(conditions) {\n    const _this = this;\n\n    this.countNodes(this.ds);\n    return new Promise(async (resolve, reject) => {\n      if (!conditions || !Object.keys(conditions).length) {\n        return reject(new Error('Parameter conditions are invalid.'));\n      }\n\n      let nodes = [];\n\n      function findNodes(obj, conditions, callback) {\n        if (!_this.count) {\n          return;\n        }\n\n        if (_this.matchConditions(obj, conditions)) {\n          nodes.push(obj);\n\n          if (_this.count === 1) {\n            _this.count = 0;\n            callback(!nodes.length ? 'The nodes don\\'t exist.' : null, nodes.slice(0));\n          }\n        } else {\n          if (_this.count === 1) {\n            _this.count = 0;\n            callback(!nodes.length ? 'The nodes don\\'t exist.' : null, nodes.slice(0));\n          }\n        }\n\n        _this.count--;\n\n        if (obj[_this.children]) {\n          obj[_this.children].forEach(child => {\n            findNodes(child, conditions, callback);\n          });\n        }\n      }\n\n      findNodes(this.ds, conditions, (msg, nodes) => {\n        if (msg) {\n          reject(new Error(msg));\n        } else {\n          resolve(nodes);\n        }\n      });\n    });\n  }\n\n  findParent(id) {\n    const _this = this;\n\n    this.countNodes(this.ds);\n    return new Promise((resolve, reject) => {\n      if (!id) {\n        return reject(new Error('Parameter id is invalid.'));\n      }\n\n      function findParent(obj, id, callback) {\n        if (_this.count === 1) {\n          _this.count = 0;\n          callback('The parent node doesn\\'t exist.', null);\n        } else {\n          _this.count--;\n\n          if (typeof obj[_this.children] !== 'undefined') {\n            obj[_this.children].forEach(function (child) {\n              if (child[_this.id] === id) {\n                _this.count = 0;\n                callback(null, obj);\n              }\n            });\n\n            obj[_this.children].forEach(function (child) {\n              findParent(child, id, callback);\n            });\n          }\n        }\n      }\n\n      findParent(this.ds, id, (msg, parent) => {\n        if (msg) {\n          reject(new Error(msg));\n        } else {\n          resolve(parent);\n        }\n      });\n    });\n  }\n\n  async findSiblings(id) {\n    const _this = this;\n\n    if (!id) {\n      throw new Error('Parameter id is invalid.');\n    }\n\n    try {\n      const parent = await this.findParent(id);\n      return parent[this.children].filter(child => {\n        return child[_this.id] !== id;\n      });\n    } catch (err) {\n      throw new Error('The sibling nodes don\\'t exist.');\n    }\n  }\n\n  findAncestors(id) {\n    const _this = this;\n\n    return new Promise(async (resolve, reject) => {\n      if (!id) {\n        return reject(new Error('Parameter id is invalid.'));\n      }\n\n      let nodes = [];\n\n      async function findAncestors(id) {\n        try {\n          if (id === _this.ds[_this.id]) {\n            if (!nodes.length) {\n              throw new Error('The ancestor nodes don\\'t exist.');\n            }\n\n            return nodes.slice(0);\n          } else {\n            const parent = await _this.findParent(id);\n            nodes.push(parent);\n            return findAncestors(parent[_this.id]);\n          }\n        } catch (err) {\n          throw new Error('The ancestor nodes don\\'t exist.');\n        }\n      }\n\n      try {\n        const ancestors = await findAncestors(id);\n        resolve(ancestors);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  } // validate the input parameters id and data(could be oject or array)\n\n\n  validateParams(id, data) {\n    if (!id) {\n      throw new Error('Parameter id is invalid.');\n    }\n\n    if (!data || data.constructor !== Object && data.constructor !== Array || data.constructor === Object && !Object.keys(data).length || data.constructor === Array && !data.length || data.constructor === Array && data.length && !data.every(item => item && item.constructor === Object && Object.keys(item).length)) {\n      throw new Error('Parameter data is invalid.');\n    }\n  }\n\n  async addChildren(id, data) {\n    this.validateParams(id, data);\n\n    try {\n      const parent = await this.findNodeById(id);\n\n      if (data.constructor === Object) {\n        if (parent[this.children]) {\n          parent[this.children].push(data);\n        } else {\n          parent[this.children] = [data];\n        }\n      } else {\n        if (parent[this.children]) {\n          parent[this.children].push(...data);\n        } else {\n          parent[this.children] = data;\n        }\n      }\n    } catch (err) {\n      throw new Error('Failed to add child nodes.');\n    }\n  }\n\n  async addSiblings(id, data) {\n    this.validateParams(id, data);\n\n    try {\n      const parent = await this.findParent(id);\n\n      if (data.constructor === Object) {\n        parent[this.children].push(data);\n      } else {\n        parent[this.children].push(...data);\n      }\n    } catch (err) {\n      throw new Error('Failed to add sibling nodes.');\n    }\n  }\n\n  addRoot(data) {\n    const _this = this;\n\n    if (!data || data.constructor !== Object || data.constructor === Object && !Object.keys(data).length) {\n      throw new Error('Parameter data is invalid.');\n    }\n\n    try {\n      this.ds[this.children] = [Object.assign({}, this.ds)];\n      delete data[this.children];\n      Object.keys(this.ds).filter(prop => prop !== this.children).forEach(prop => {\n        if (!data[prop]) {\n          delete this.ds[prop];\n        }\n      });\n      Object.assign(this.ds, data);\n    } catch (err) {\n      throw new Error('Failed to add root node.');\n    }\n  }\n\n  async updateNode(data) {\n    if (!data || data.constructor !== Object || data.constructor === Object && !Object.keys(data).length || data.constructor === Object && Object.keys(data).length && !data[this.id]) {\n      throw new Error('Parameter data is invalid.');\n    }\n\n    try {\n      const node = await this.findNodeById(data[this.id]);\n      Object.assign(node, data);\n    } catch (err) {\n      throw new Error('Failed to update node.');\n    }\n  }\n\n  async updateNodes(ids, data) {\n    const _this = this;\n\n    if (!ids || ids.constructor === Array && !ids.length || !data) {\n      throw new Error('Input parameter is invalid.');\n    }\n\n    try {\n      for (const id of ids) {\n        data[_this.id] = id;\n        await this.updateNode(data);\n      }\n    } catch (err) {\n      throw err;\n    }\n  } // remove single node based on id\n\n\n  async removeNode(id) {\n    const _this = this;\n\n    if (id === this.ds[this.id]) {\n      throw new Error('Input parameter is invalid.');\n    }\n\n    const parent = await this.findParent(id);\n    const index = parent[this.children].map(node => node[_this.id]).indexOf(id);\n    parent[this.children].splice(index, 1);\n    this.count = 0;\n  } // param could be single id, id array or conditions object\n\n\n  async removeNodes(param) {\n    const _this = this;\n\n    if (!param || param.constructor === Array && !param.length || param.constructor === Object && !Object.keys(param).length) {\n      throw new Error('Input parameter is invalid.');\n    }\n\n    try {\n      // if passing in single id\n      if (param.constructor === String || param.constructor === Number) {\n        await this.removeNode(param);\n      } else if (param.constructor === Array) {\n        // if passing in id array\n        for (const p of param) {\n          await this.removeNode(p);\n        }\n      } else {\n        // if passing in conditions object\n        const nodes = await this.findNodes(param);\n        const ids = nodes.map(node => node[_this.id]);\n\n        for (const p of ids) {\n          await this.removeNode(p);\n        }\n      }\n    } catch (err) {\n      throw new Error('Failed to remove nodes.');\n    }\n  }\n\n}\n\nexports.default = JSONDigger;\n;\n"]},"metadata":{},"sourceType":"script"}